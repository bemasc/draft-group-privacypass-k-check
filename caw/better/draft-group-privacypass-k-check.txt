



Privacy Pass                                                      J. Doe
Internet-Draft                                                      Mars
Intended status: Standards Track                            27 June 2023
Expires: 29 December 2023


           The K-Check Protocol for HTTP Resource Consistency
                 draft-group-privacypass-k-check-latest

Abstract

   TODO Abstract

About This Document

   This note is to be removed before publishing as an RFC.

   Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-group-privacypass-k-check/.

   Discussion of this document takes place on the Privacy Pass Working
   Group mailing list (mailto:privacy-pass@ietf.org), which is archived
   at https://mailarchive.ietf.org/arch/browse/privacy-pass/.  Subscribe
   at https://www.ietf.org/mailman/listinfo/privacy-pass/.

   Source for this draft and an issue tracker can be found at
   https://github.com/chris-wood/draft-group-privacypass-K-Check.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 29 December 2023.

Copyright Notice

   Copyright (c) 2023 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Terminology
   4.  Mirror Protocol
     4.1.  Mirror Request and Respnose Example
   5.  K-Check
     5.1.  Privacy Pass Profile
     5.2.  Oblivious HTTP Profile
   6.  Consistency Properties
   7.  Security Considerations
   8.  IANA Considerations
   9.  References
     9.1.  Normative References
     9.2.  Informative References
   Acknowledgments
   Author's Address

1.  Introduction

   This document describes a protocol mechanism based on [DoubleCheck]
   for checking that an HTTP resource is consistent with the view of one
   or more mirrors.  In this context, a mirror is an HTTP server that
   fetches and caches copies of an HTTP resource for clients to use for
   consistency checks.  More specifically, clients obtain copies of a
   desired resource from a mirror and then compare those copies to their
   resource.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Terminology

   The following terms are used throughout this document:

   *  Resource: A HTTP resource identified by a URL.

   *  Normalized resource: A normalized HTTP resource representation is
      a unique or otherwise protocol-specific representation that is
      derived from an HTTP resource.  The process of normalization is
      specific to a protocol and the resource in question.

   *  Mirror: A HTTP server that fetches and caches HTTP resources.

4.  Mirror Protocol

   The mirror protocol is a simple protocol similar to a reverse-proxy.
   Each mirror is identified by a Mirror URI Template [RFC6570].  The
   scheme for the Mirror URI Template MUST be "https".  The Mirror URI
   Template uses the Level 3 encoding defined Section 1.2 of [RFC6570]
   and contains one variables: "target", which is the percent-encoded
   URL of a HTTP resource to be mirrored.  Example Mirror URI Templates
   are shown below.

   https://mirror.example/mirror{?target}
   https://mirror.example/{target}

   The Mirror URI Template MUST contain the "target" variable exactly
   once.  The variable MUST be within the path or query components of
   the URI.

   Clients send requests to mirror resources after being configured with
   their corresponding Mirror URI Template.  Clients MUST ignore
   configurations that do not conform to this template.

   Upon receipt of a mirror request, mirrors validate the incoming
   request.  If the request is invalid or malformed, e.g., the "target"
   parameter is not a correctly encoded URL, the mirror aborts and
   returns a a 4xx (Client Error) to the client.  Otherwise, if the
   request is valid, the mirror checks to see if it has a cached version
   of the resource identified by the target URL.  If so, this response
   is returned to the client.

   Otherwise, mirrors send a GET request to the target resource URL.  If
   this request fails, the mirror returns a 4xx error to the client.
   Otherwise, the response to a mirror request is the content that was
   contained in the target resource.  With the exception of Content-
   Type, Content-Length, and Cache-Control headers, the mirror response
   does not replicate any of the headers that may have been attached to
   the HTTP message carrying the target resource.

   Mirrors cache this content, indexed by the target URL, for future
   mirror requests.  Mirrors purge this cache when the response is no
   longer valid according to the Cache-Control headers.

   We refer to the set of clients that interact with a mirror as mirror
   clients.  We refer to the validity window of the mirror response as
   the period of time determined by the Cache-Control headers as the
   response.

   [[OPEN ISSUE: Should there be some mandatory or RECOMMENDED minimum
   validity window of resources?]]

4.1.  Mirror Request and Respnose Example

   The following example shows two mirror request and response examples.
   The first one yields a mirror cache miss and the second one yields a
   mirror cache hit.  The Mirror URI Template is
   "https://mirror.example/mirror{?target}", and the target URL is
   "https://issuer.example/.well-known/private-token-issuer-directory".

   The first client request to the mirror might be the following.

:method = GET
:scheme = https
:authority = mirror.example
:path = /mirror?target=https%3A%2F%2Fissuer.example%2F.well-known%2Fprivate-token-issuer-directory

   Upon receipt, the mirror decodes the "target" parameter, inspects its
   cache for a copy of the resource, and then constructs a HTTP request
   to the target URL to fetch the content.  This mirror request to the
   target might be the following.

   :method = GET
   :scheme = https
   :authority = target.example
   :path = /.well-known/private-token-issuer-directory

   The target response is then returned to the mirror, like so:

   :status = 200
   content-type = application/private-token-issuer-directory
   content-length = ...
   cache-control: max-age=3600

   <Bytes containing a private token issuer directory>

   The mirror caches this response content for the target URL and then
   returns the response to the client, with all headers except for
   content-type, content-length, and cache-control stripped, like so:

   :status = 200
   content-type = application/private-token-issuer-directory
   content-length = ...
   cache-control: max-age=3600

   <Bytes containing a private token issuer directory>

   When a second client asks for the same request by the mirror it can
   be served with the cached copy.  The second client's request might be
   the following:

:method = GET
:scheme = https
:authority = mirror.example
:path = /mirror?target=https%3A%2F%2Fissuer.example%2F.well-known%2Fprivate-token-issuer-directory

   The mirror validates the request, locates the cached copy of the
   "https://issuer.example/.well-known/private-token-issuer-directory"
   content, and then returns it to the client without updating its
   cached copy.

   :status = 200
   content-type = application/private-token-issuer-directory
   content-length = ...
   cache-control: max-age=3600

   <Bytes containing a private token issuer directory>

5.  K-Check

   Clients are configured with the URLs for one or more mirror servers.
   Each URL identifies an API endpoint that clients use to obtain
   mirrored copies of a resource.

   The input to K-Check is a candidate HTTP resource, a target URL at
   which the resource was obtained, and a normalized representation of
   the input resource.  To check this resource, the client runs the
   following steps for each configured mirror.

   1.  Send a mirror request to the mirror for the target URL.  If the
       request fails, fail this mirror check.

   2.  Otherwise, compute normalized values for the resource based on
       the mirror's response.

   3.  Compare the normalized values to the input normalized
       representation.  If none match, fail this mirror check.
       Otherwise, if there exists one matching resource normalized
       representation, this mirror check succeeds.

   If all mirror checks succeed, the client outputs success.  Otherwise,
   the client has detected an inconsistency and outputs fail.

   [[OPEN ISSUE: Can mirrors somehow communicate the number of “active
   users” to clients?  How would mirrors determine client uniqueness?
   And finally, if mirrors did this accurately, how would clients use
   this information?]]

5.1.  Privacy Pass Profile

   Clients are given as input an issuer token key from an origin server
   and want to check whether it is consistent with the key that is given
   to other clients.  Let the input key be denoted token_key and its
   identifier be token_key_id.  Clients are also given as input the name
   of the issuer, from which they can construct the target URL for the
   issuer directory.  If clients have already checked this issuer’s
   token key, i.e., they’ve previously run K-Check, they can simply
   reuse the result up to its expiration.  Otherwise, clients invoke
   K-Check in parallel with the issuance protocol.

   Each issuer directory can yield one or more normalized
   representations that clients use in the K-Check protocol.  For
   example, given a mirrored token directory resource like the
   following:

   {
     "issuer-request-uri": "https://issuer.example.net/request",
     "token-keys": [
       {
         "token-type": 2,
         "token-key": "MI...AB",
       },
       {
         "token-type": 2,
         "token-key": "MI...AQ",
       }
     ]
   }

   Clients would take each “token-key” parameter, base64url-decode the
   result, and then derive a token key identifier as defined in the
   specification.  Each token key identifier is a normalized
   representation of the resource.

5.2.  Oblivious HTTP Profile

   Clients can run K-Check for OHTTP in several ways depending on the
   deployment.  In practice, common deployments are as follows:

   1.  Clients are configured with gateway configurations; and

   2.  Clients fetch gateway configurations before use.

   In both cases, clients begin with a gateway configuration and want to
   check it for consistency.  In OHTTP, there is exactly one normalized
   resource representation for a gateway configuration – the
   configuration itself.  Before using the configuration to encrypt a
   binary HTTP message to the gateway, clients can run K-Check with
   their configured mirrors to ensure that this configuration is correct
   for the given gateway.

6.  Consistency Properties

   The consistency properties of K-Check are as follows:

   1.  With honest mirrors, clients that successfully check a resource
       are assured that they share the same copy of the resource with
       the union of mirror clients for each configured mirror.

   2.  Consistency only holds for the period of time of the minimum
       mirror validity window.

   3.  With at least one dishonest mirror, the probability of
       discovering an inconsistency is 1 - (1 / 2^(k-1)).  This is the
       probability that each individual mirror check succeeds in the
       mirror protocol.

7.  Security Considerations

   TODO Security

8.  IANA Considerations

   This document has no IANA actions.

9.  References

9.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC6570]  Gregorio, J., Fielding, R., Hadley, M., Nottingham, M.,
              and D. Orchard, "URI Template", RFC 6570,
              DOI 10.17487/RFC6570, March 2012,
              <https://www.rfc-editor.org/rfc/rfc6570>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

9.2.  Informative References

   [DoubleCheck]
              Schwartz, B. M., "Key Consistency by Double-Checking via a
              Semi-Trusted Proxy", Work in Progress, Internet-Draft,
              draft-schwartz-ohai-consistency-doublecheck-03, 19 October
              2022, <https://datatracker.ietf.org/doc/html/draft-
              schwartz-ohai-consistency-doublecheck-03>.

Acknowledgments

   This document is based on the [DoubleCheck] protocol from Benjamin
   Schwartz.

Author's Address

   J. Doe
   Mars
   Email: jdoe@weylandyutani.com
